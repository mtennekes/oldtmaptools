% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aggregate_map.R
\name{aggregate_map}
\alias{aggregate_map}
\title{Aggregate map}
\usage{
aggregate_map(shp, by = NULL, fact = NULL, agg.fun = NULL,
  weights = NULL, na.rm = FALSE, ...)
}
\arguments{
\item{shp}{shape object, which is one of
\enumerate{
 \item{\code{\link[sp:SpatialPolygonsDataFrame]{SpatialPolygons(DataFrame)}}}
 \item{\code{\link[sp:SpatialLinesDataFrame]{SpatialLines(DataFrame)}}}
 \item{\code{\link[sp:SpatialGridDataFrame]{SpatialGrid(DataFrame)}}}
 \item{\code{\link[sp:SpatialPixelsDataFrame]{SpatialPixels(DataFrame)}}}
 \item{\code{\link[raster:Raster-class]{RasterLayer, RasterStack, or RasterBrick}}}
 \item{\code{\link[sf:sf]{sf}} object if it can be coerced to an \code{\link[sp:sp]{sp}} object}
}}

\item{by}{variable by which polygons or lines are merged. Does not apply to raster objects.}

\item{fact}{number that specifies how many cells in both horizontal and vertical direction are merged. Only applied to raster objects.}

\item{agg.fun}{aggregation function(s). One of the following formats:
\enumerate{
\item{One function (name) by which all variables are aggregated.}
\item{A vector of two function names called \code{"num"} and \code{"cat"} that determine the functions by which numeric respectively categorical variables are aggregated. For instance \code{c(num="mean", cat="modal")}, which calculates the mean and mode for numeric respectively categorical variables.}
\item{A list where per variable the (names of the) function(s) are provided. The list names should correspond to the variable names.}
}
These predefined functions can be used: \code{"mean"}, \code{"modal"}, \code{"first"}, and \code{"last"}.}

\item{weights}{name of a numeric variable in \code{shp}. The values serve as weights for the aggregation function. If provided, these values are passed on as second argument. Works with aggregation functions \code{"mean"} and \code{"modal"}. Use \code{"AREA"} for polygon area sizes.}

\item{na.rm}{passed on to the aggregation function(s) \code{agg.fun}.}

\item{...}{other arguments passed on to the aggregation function(s) \code{agg.fun}.}
}
\value{
A shape object, in the same format as \code{shp}
}
\description{
Aggregate spatial polygons, spatial lines or raster objects. For spatial polygons and lines, the units will be merged with the \code{by} variable. For rasters, the \code{fact} parameter determined how many rasters cells are aggregated both horizontally and vertically. Per data variable, an aggregation formula can be specified, by default mean for numeric and modal for categorical varaibles. Note that this function supports \code{sf} objects, but still uses sp-based methods (see details).
}
\details{
This function is similar to \code{\link[raster:aggregate]{aggregate}} from the \code{raster} package. However, the aggregation can be specified in more detail: weights can be used (e.g. polygon area sizes). Also, an aggregation function can be specified per variable or raster layer. It is also possible to specify a general function for numeric data and a function for categorical data.

By default, the data is not aggregated. In this case, this function is similar to \code{unionSpatialPolygons} from the \code{maptools} package. The only difference is way the aggregate-by variable is specified. When using \code{unionSpatialPolygons}, the values have to be assigned to \code{IDs} whereas when using \code{aggregate_map} the data variable name can be assigned to \code{by}.

The underlying functions of \code{aggregate_map} for \code{\link[sp:sp]{sp}} objects are \code{\link[rgeos:gUnaryUnion]{gUnaryUnion}}, \code{\link[rgeos:gUnionCascaded]{gUnionCascaded}}, and \code{\link[rgeos:gLineMerge]{gLineMerge}}. For \code{Raster} objects, the \code{\link[raster:aggregate]{aggregate}} is used.

This function supports \code{\link[sf:sf]{sf}} objects, but still uses sp-based methods, from the packages sp, rgeos, and/or rgdal. Alternatively, the \code{\link[sf:tidyverse]{tidyverse}} methods \code{group_by} and \code{summarize} can be used.
}
\examples{
\dontrun{
if (require(tmap) && packageVersion("tmap") >= "2.0") {
    data(land)

    # original map
    qtm(land, raster="cover_cls")

    # map decreased by factor 4 for each dimension
    land4 <- aggregate_map(land, fact=4, agg.fun="modal")
    qtm(land4, raster="cover_cls")

    # map decreased by factor 8, where the variable trees is
    # aggregated with mean, min, and max
    land_trees <- aggregate_map(land, fact=8,
        agg.fun=list(trees="mean", trees="min", trees="max"))

    tm_shape(land_trees) +
    	tm_raster(c("trees.1", "trees.2", "trees.3"), title="Trees (\%)") +
    	tm_facets(free.scales=FALSE) +
    	tm_layout(panel.labels = c("mean", "min", "max"))

    data(NLD_muni, NLD_prov)

    # aggregate Dutch municipalities to provinces
    NLD_prov2 <- aggregate_map(NLD_muni, by="province",
        agg.fun = list(population="sum", origin_native="mean", origin_west="mean",
        origin_non_west="mean", name="modal"), weights = "population")

    # see original provinces data
    as.data.frame(NLD_prov)[, c("name", "population", "origin_native",
                                "origin_west", "origin_non_west")]

    # see aggregates data (the last column corresponds to the most populated municipalities)
    sf::st_set_geometry(NLD_prov2, NULL)

    # largest municipalities in area per province
    NLD_largest_muni <- aggregate_map(NLD_muni, by="province",
        agg.fun = list(name="modal"), weights = "AREA")

    sf::st_set_geometry(NLD_largest_muni, NULL)
}
}
}
